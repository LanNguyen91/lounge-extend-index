'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _privatekey = require('./privatekey');

var _privatekey2 = _interopRequireDefault(_privatekey);

var _utils = require('./utils');

var _normalize = require('./normalize');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _extendableBuiltin(cls) {
  function ExtendableBuiltin() {
    var instance = Reflect.construct(cls, Array.from(arguments));
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    return instance;
  }

  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }

  return ExtendableBuiltin;
}

var ObjectArray = function (_extendableBuiltin2) {
  _inherits(ObjectArray, _extendableBuiltin2);

  /**
   * @classdesc Represents a basic array with typecasted values. Inherits <code>Array</code>
   * Clients to not need to manually create instances of this class.
   *
   * @description Clients to not need to manually create instances of this class.
   * @class
   * @param self
   * @param properties
   */
  function ObjectArray(self, properties) {
    _classCallCheck(this, ObjectArray);

    // need check for some reason fn's like map() create new instance and pass in size?
    var _this = _possibleConstructorReturn(this, (ObjectArray.__proto__ || Object.getPrototypeOf(ObjectArray)).call(this));

    if (self && properties) {
      // Store all internals.
      var _private = _this[_privatekey2.default] = {};

      // Store reference to self.
      _private._self = self;

      // Store properties (arrayType, unique, etc).
      _private._properties = properties;

      // Normalize our own properties.
      if (properties.arrayType) {
        properties.arrayType = _normalize.normalizeProperties.call(self, properties.arrayType);
      }
    }
    return _this;
  }

  _createClass(ObjectArray, [{
    key: 'push',
    value: function push() {
      var _this2 = this;

      // Values are passed through the typecast before being allowed onto the array if arrayType is set.
      // In the case of rejection, the typecast returns undefined, which is not appended to the array.
      var values = void 0;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (this[_privatekey2.default]._properties.arrayType) {
        values = [].map.call(args, function (value) {
          try {
            return _utils.typecast.call(_this2[_privatekey2.default]._self, value, undefined, _this2[_privatekey2.default]._properties.arrayType);
          } catch (err) {
            // set it the root parent object
            if (_this2[_privatekey2.default]._self && _this2[_privatekey2.default]._self[_privatekey2.default] && _this2[_privatekey2.default]._self[_privatekey2.default]._errors) {
              _this2[_privatekey2.default]._self[_privatekey2.default]._errors.push(err);
            }
            return undefined;
          }
        }, this);

        // remove undefined and nulls
        values = _lodash2.default.compact(values);
      } else {
        values = args;
      }

      if (this[_privatekey2.default]._properties.unique) {
        values = _lodash2.default.difference(values, _lodash2.default.toArray(this));
      }

      return Array.prototype.push.apply(this, values);
    }
  }, {
    key: 'concat',
    value: function concat() {
      // Return new instance of SchemaArray.
      var schemaArray = new ObjectArray(this[_privatekey2.default]._self, this[_privatekey2.default]._properties);

      // Create primitive array with all elements.
      var array = this.toArray();

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      for (var i in args) {
        if (args[i].toArray) {
          args[i] = args[i].toArray();
        }
        array = array.concat(args[i]);
      }

      // Push each value in individually to typecast.
      for (var _i in array) {
        schemaArray.push(array[_i]);
      }

      return schemaArray;
    }
  }, {
    key: 'toArray',
    value: function toArray() {
      // Create new Array to hold elements.
      var array = [];

      // Loop through each element, clone if necessary.
      _lodash2.default.each(this, function (element) {
        // Call toObject() method if defined (this allows us to return primitive objects instead of Document instances).
        if (_lodash2.default.isObject(element) && _lodash2.default.isFunction(element.toObject)) {
          element = element.toObject();

          // If is non-SchemaType object, shallow clone so that properties modification don't have an affect on the original object.
        } else if (_lodash2.default.isObject(element)) {
          element = _lodash2.default.clone(element);
        }

        array.push(element);
      });

      return array;
    }
  }, {
    key: 'set',
    value: function set(array) {
      var _this3 = this;

      var ok = true;
      _lodash2.default.each(array, function (arrayValue) {
        try {
          _utils.typecast.call(_this3[_privatekey2.default]._self, arrayValue, undefined, _this3[_privatekey2.default]._properties.arrayType);
        } catch (err) {
          ok = false;
          // set it the root parent object
          if (_this3[_privatekey2.default]._self && _this3[_privatekey2.default]._self[_privatekey2.default] && _this3[_privatekey2.default]._self[_privatekey2.default]._errors) {
            _this3[_privatekey2.default]._self[_privatekey2.default]._errors.push(err);
          }
        }
      });

      if (ok) {
        this.length = 0;
        this.push.apply(this, _toConsumableArray(array));
      }
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return this.toArray();
    }

    /**
     *  Used to detect instance of SchemaArray internally.
     * @returns {boolean}
     * @private
     */

  }, {
    key: '_isObjectArray',
    value: function _isObjectArray() {
      return true;
    }
  }]);

  return ObjectArray;
}(_extendableBuiltin(Array));

exports.default = ObjectArray;