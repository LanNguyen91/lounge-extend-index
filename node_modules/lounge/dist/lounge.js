'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _couchbase = require('couchbase');

var _couchbase2 = _interopRequireDefault(_couchbase);

var _couchbaseDriver = require('couchbase-driver');

var _couchbaseDriver2 = _interopRequireDefault(_couchbaseDriver);

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

var _schema = require('./schema');

var _schema2 = _interopRequireDefault(_schema);

var _document = require('./document');

var _document2 = _interopRequireDefault(_document);

var _cbdocument = require('./cbdocument');

var _cbdocument2 = _interopRequireDefault(_cbdocument);

var _model = require('./model');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var debug = require('debug')('lounge');

var schemaConfigOptions = utils.schemaConfigOptionKeys;

var Lounge = function (_EventEmitter) {
  _inherits(Lounge, _EventEmitter);

  /**
   * @classdesc The Lounge module
   * The exports object of the <code>lounge</code> module is an instance of this class.
   * Most apps will only use this one instance. We copy all Couchbase <code>Bucket</code> methods and properties
   * so you can call them generically from this instance as well.
   *
   * @description The Lounge constructor
   * @class
   * @augments Bucket
   * @param {Object} options
   * @param {String} options.keyPrefix - key prefix for all keys. No default. Generally useful if you wish to namespace documents. Example: <code>app::env::</code>.
   * @param {String} options.keySuffix - Similar as prefix but used as a suffix
   * @param {Boolean} options.storeFullReferenceId - whether to store embedded document keys as fully expanded keys (with prefix and suffix applied)
   * or just the minimized version. default: <code>false</code>
   * @param {Boolean} options.storeFullKey - Similarly to store the fully expanded document key inside the key property. default: <code>false</code>
   * @param {Boolean} options.alwaysReturnArrays - set to true to force <code>findyById</code> to always return an array of documents even if only a single key is passed in
   * @param {String} options.refIndexKeyPrefix - reference lookup index document key prefix. The name of the index is appended. default: <code>$_ref_by_</code>
   * @param {String} options.delimiter - delimiter string used for concatenation in reference document key expansion / generation. default: <code>'_'</code>. This is prepended to the reference document key.
   * @param {Boolean} options.waitForIndex - When documents are saved, indexes are updated. We can wait for this operation to finish before
   * returning from <code>save()</code>. Default: <code>false</code>
   * @param {Boolean} options.minimize - "minimize" schemas by removing empty objects. Default: <code>true</code>
   * @param {Boolean} options.missing By default the <code>findById</code> and index query functions return 3 parameters to the callback:
   *                                  <code>(err, docs, missing)</code>. If this option is set to <code>false</code> we won't return
   *                                  missing keys as the final param in the callback. Default: <code>true</code>.
   * @param {Number} options.atomicRetryTimes - The number of attempts to make within <code>Driver.atomic()</code>. Default: <code>5</code>.
   *                                            See {@link https://github.com/bojand/couchbase-driver}
   * @param {Number} options.atomicRetryInterval - The time to wait between retries, in milliseconds, within <code>Driver.atomic()</code>.
   *                                               Default: <code>0</code>. See {@link https://github.com/bojand/couchbase-driver}
   * @param {Boolean} options.atomicLock - Whether to use <code>getAndLock</code> or standard <code>get</code> during atomic
   *                                       operations within indexing. Default: <code>true</code>.
   *                                       See {@link https://github.com/bojand/couchbase-driver}
   * @param {Boolean} options.promisify - to enable promise support. By default all async functions support promises and return a promise.
   *                                      To disable promise support set this  option to <code>false</code>, ideally at start before
   *                                      doing <code>connect</code> or any other operations. Default: <code>true</code>.
   *
   * @returns {Lounge}
   */
  function Lounge() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Lounge);

    var _this = _possibleConstructorReturn(this, (Lounge.__proto__ || Object.getPrototypeOf(Lounge)).call(this));

    _this.models = {};
    _this.bucket = null;
    _this.db = null;
    _this.config = _lodash2.default.defaults(options || {}, utils.defaultOptions);
    return _this;
  }

  /**
   * Connect to the database. You may define Models before connecting, but you should not create any actual document
   * instances before connecting to the database.
   * @public
   * @param {Object} options
   * @param {String} options.connectionString - connection string for the cluster
   * @param {String|Bucket} options.bucket - name of the bucket or the actual Couchbase <code>bucket</code> instance
   * @param {String} options.password - password
   * @param {String} options.certpath - certpath for cluster
   * @param {Boolean} options.mock - whether to use mocking
   * @param {Function} fn callback
   * @return {Bucket} Couchbase <code>Bucket</code> instance
   * @example
   * lounge.connect({
   *   connectionString: 'couchbase://127.0.0.1',
   *   bucket: 'lounge_test'
   * });
   */


  _createClass(Lounge, [{
    key: 'connect',
    value: function connect(options, fn) {
      return utils.promisifyCall.apply(utils, [this, this._connect].concat(Array.prototype.slice.call(arguments)));
    }
  }, {
    key: '_connect',
    value: function _connect(options, fn) {
      if (!options) {
        throw new Error('Need options for connect()');
      }

      if (!fn) {
        fn = _lodash2.default.noop;
      }

      var self = this;

      function retFn(err, bucket) {
        var b = bucket || self.bucket;
        if (b) {
          self.db = _couchbaseDriver2.default.create(b, self.config);
          if (self.models) {
            for (var k in self.models) {
              if (self.models.hasOwnProperty(k)) {
                var m = self.models[k];
                m._private.db = self.db;
              }
            }
          }
        }
        return fn(err, bucket || self.bucket);
      }

      if (options.bucket && _typeof(options.bucket) === 'object') {
        this.bucket = options.bucket;

        if (this.bucket) {
          this.db = _couchbaseDriver2.default.create(this.bucket, this.config);
          this.db.models = this.models;
        }

        return retFn(null, this.bucket);
      } else if (options.bucket && typeof options.bucket === 'string' && options.connectionString && typeof options.connectionString === 'string') {
        debug('connect. cluster: ' + options.connectionString + ' bucket: ' + options.bucket);

        var custerOpts = options.certpath ? {
          certpath: options.certpath
        } : null;
        var ClusterCtor = options.mock || process.env.LOUNGE_COUCHBASE_MOCK ? _couchbase2.default.Mock.Cluster : _couchbase2.default.Cluster;
        var args = options.password ? [options.bucket, options.password, retFn] : [options.bucket, retFn];

        var cluster = new ClusterCtor(options.connectionString, custerOpts);
        this.bucket = cluster.openBucket.apply(cluster, args);
      }
    }

    /**
     * Disconnect from the bucket. Deletes all defined models.
     */

  }, {
    key: 'disconnect',
    value: function disconnect() {
      debug('disconnect');
      if (this.bucket) {
        this.bucket.disconnect();
      }

      delete this.models;
      delete this.db;

      this.models = {};
      this.db = null;
    }

    /**
     * Creates a schema. Prefer to use this over Schema constructor as this will pass along Lounge config settings.
     *
     * @public
     * @param {Object} descriptor the schema descriptor
     * @param {Object} options Schema options
     * @return {Schema} created <code>Schema</code> instance
     * @example
     * var schema = lounge.schema({ name: String });
     */

  }, {
    key: 'schema',
    value: function schema(descriptor) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var opts = _lodash2.default.defaults(options, _lodash2.default.pick(this.config, schemaConfigOptions));
      return new _schema2.default(descriptor, opts);
    }

    /**
     * Creates a model from a schema.
     *
     * @public
     * @param {String} name name of the model.
     * @param {Schema} schema instance
     * @param {Object} options
     * @param {Object} options.freeze - to Freeze model. See <code>Object.freeze</code>. Default: <code>true</code>
     * @returns {ModelInstance} The created <code>ModelInstance</code> class.
     * @example
     * var Cat = lounge.model('Cat', schema);
     */

  }, {
    key: 'model',
    value: function model(name, schema) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (!(schema instanceof _schema2.default)) {
        var opts = _lodash2.default.defaults(options, _lodash2.default.pick(this.config, schemaConfigOptions));
        schema = new _schema2.default(schema, opts);
      }

      if (this.models[name]) {
        return this.models[name];
      }

      var M = (0, _model.compile)(schema, options, name, this);
      this.models[name] = M;
      return M;
    }

    /**
     * Returns the model given the name.
     * @param name
     * @returns {Model|undefined} The <code>ModelInstance</code> or <code>undefined</code> if the model by that name does
     * not exist.
     * @example
     * var Cat = lounge.getModel('Cat');
     */

  }, {
    key: 'getModel',
    value: function getModel(name) {
      return this.models[name];
    }

    /**
     * Sets lounge config options
     *
     * @public
     * @param key {String} the config key
     * @param value {*} option value
     */

  }, {
    key: 'setOption',
    value: function setOption(key, value) {
      if (arguments.length === 1) {
        return this.config[key];
      }

      this.config[key] = value;
      return this;
    }

    /**
     * Get config option.
     * @param key {String} the config key
     * @return {*} Option value
     */

  }, {
    key: 'getOption',
    value: function getOption(key) {
      return this.setOption(key);
    }

    /**
     * Returns an array of model names created on this instance of Lounge.
     *
     * @public
     * @return {Array} Array of model names registered.
     * @example
     * console.log(lounge.modelNames()); // [ 'Cat', 'Dog' ]
     */

  }, {
    key: 'modelNames',
    value: function modelNames() {
      return Object.keys(this.models);
    }

    /**
     * The Lounge Schema constructor
     *
     */

  }, {
    key: 'Schema',
    get: function get() {
      return _schema2.default;
    }

    /**
     * The Lounge Model constructor.
     */

  }, {
    key: 'Model',
    get: function get() {
      return _model.Model;
    }

    /**
     * The Lounge CouchbaseDocument constructor.
     */

  }, {
    key: 'CouchbaseDocument',
    get: function get() {
      return _cbdocument2.default;
    }

    /**
     * The Lounge Document constructor.
     *
     */

  }, {
    key: 'Document',
    get: function get() {
      return _document2.default;
    }

    /**
     * The Lounge constructor
     * The exports of the Lounge module is an instance of this class.
     */

  }, {
    key: 'Lounge',
    get: function get() {
      return Lounge;
    }
  }]);

  return Lounge;
}(_events.EventEmitter);

/**
 * Inherit all Couchbase Bucket functions and apply them to our bucket
 */


exports.default = Lounge;
['append', 'counter', 'get', 'getAndLock', 'getAndTouch', 'getMulti', 'getReplica', 'insert', 'manager', 'prepend', 'query', 'remove', 'replace', 'set', 'setTranscoder', 'touch', 'unlock', 'upsert'].forEach(function (key) {
  Lounge.prototype[key] = function () {
    if (this.db) {
      var _db;

      return (_db = this.db)[key].apply(_db, arguments);
    }
  };
});

/**
 * Inherit all Couchbase Bucket properties and apply them to our bucket
 */
['configThrottle', 'connectionTimeout', 'durabilityInterval', 'durabilityTimeout', 'managementTimeout', 'nodeConnectionTimeout', 'operationTimeout', 'viewTimeout'].forEach(function (key) {
  Object.defineProperty(Lounge.prototype, key, {
    get: propertyGetWrapper(key),
    set: propertySetWrapper(key)
  });
});

function propertyGetWrapper(key) {
  return function () {
    if (this.bucket) {
      return this.bucket[key];
    }
  };
}

function propertySetWrapper(key) {
  return function (value) {
    if (this.bucket) {
      this.bucket[key] = value;
    }
  };
}