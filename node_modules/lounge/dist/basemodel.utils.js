'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defineProperty = defineProperty;
exports.clearField = clearField;

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _objectarray = require('./objectarray');

var _objectarray2 = _interopRequireDefault(_objectarray);

var _utils = require('./utils');

var _privatekey = require('./privatekey');

var _privatekey2 = _interopRequireDefault(_privatekey);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function defineProperty(index, properties) {
  var _this = this;

  var indexOrAliasIndex = properties.type === 'alias' ? properties.target : index;

  Object.defineProperty(this, index, {
    configurable: true,
    get: function get() {
      try {
        return getter.call(_this, _this[_privatekey2.default]._obj[indexOrAliasIndex], properties);
      } catch (err) {
        // This typically happens when the default value isn't valid -- log error.
        _this[_privatekey2.default]._errors.push(err);
      }
    },
    set: function set(value) {
      // Don't proceed if readOnly is true.
      if (properties.readOnly) {
        return;
      }

      // call custom validate if specified
      if (properties.validate) {
        if (!properties.validate.call(_this, value)) {
          return;
        }
      }

      try {
        // this[_privateKey]._this[index] is used instead of this[_privateKey]._obj[index] to route through the public interface.
        writeValue.call(_this[_privatekey2.default]._this, _utils.typecast.call(_this, value, _this[_privatekey2.default]._this[index], properties), properties);
      } catch (err) {
        // Setter failed to validate value -- log error.
        _this[_privatekey2.default]._errors.push(err);
      }
    }
  });

  // Aliased fields reflect values on other fields and do not need to be initialized.
  if (properties.isAlias === true) {
    return;
  }

  if (properties.virtual === true) {
    return;
  }

  if (properties.type === 'object' && properties.default !== undefined) {
    writeValue.call(this[_privatekey2.default]._this, _lodash2.default.isFunction(properties.default) ? properties.default.call(this) : properties.default, properties);
  } else if (properties.type === 'array') {
    // Native arrays are never used so that toArray can be globally supported.
    // Additionally, other properties such as unique rely on passing through us.
    writeValue.call(this[_privatekey2.default]._this, new _objectarray2.default(this, properties), properties);
  }
}

// Used to fetch current values.
function getter(value, properties) {
  // Most calculations happen within the typecast and the value passed is typically the value we want to use.
  // Typically, the getter just returns the value.
  // Modifications to the value within the getter are not written to the object.

  // Getter can transform value after typecast.
  if (properties.get) {
    value = properties.get.call(this, value);
  }

  return value;
}

// Used to write value to object.
function writeValue(value, fieldSchema) {
  // onBeforeValueSet allows you to cancel the operation.
  // It doesn't work like transform and others that allow you to modify the value because all typecast has already happened.
  // For use-cases where you need to modify the value, you can set a new value in the handler and return false.
  if (this.schema.options.onBeforeValueSet) {
    if (this.schema.options.onBeforeValueSet.call(this, fieldSchema.name, value) === false) {
      return;
    }
  }

  // Alias simply copies the value without actually writing it to alias target.
  // Because the value isn't actually set on the alias target, onValueSet isn't fired.
  if (fieldSchema.type === 'alias') {
    this[fieldSchema.target] = value;
    return;
  }

  // if virtual and set specified call it
  if (fieldSchema.virtual === true) {
    if (fieldSchema.set) {
      value = fieldSchema.set.call(this, value);
    } else {
      return;
    }
  }

  // Write the value to the inner object.
  this[_privatekey2.default]._obj[fieldSchema.name] = value;

  // onValueSet notifies you after a value has been written.
  if (this.schema.options.onValueSet) {
    this.schema.options.onValueSet.call(this, fieldSchema.name, value);
  }
}

// Reset field to default value.
function clearField(index, properties) {
  // Aliased fields reflect values on other fields and do not need to be cleared.
  if (properties.isAlias === true) {
    return;
  }

  // If the property value is already not set, there's nothing to do.
  if (typeof this[properties.name] === 'undefined') {
    return;
  }

  // In case of object & array, they must be initialized immediately.
  if (properties.type === 'object') {
    if (this[properties.name] !== null && this[properties.name].clear) {
      this[properties.name].clear();
    } else {
      writeValue.call(this[_privatekey2.default]._this, undefined, properties);
    }

    // Native arrays are never used so that toArray can be globally supported.
    // Additionally, other properties such as unique rely on passing through Document.
  } else if (properties.type === 'array') {
    this[properties.name].length = 0;

    // Other field types can simply have their value set to undefined.
  } else {
    writeValue.call(this[_privatekey2.default]._this, undefined, properties);
  }
}