'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PlainBaseModel = exports.BaseModel = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _clone = require('clone');

var _clone2 = _interopRequireDefault(_clone);

var _util = require('util');

var _privatekey = require('./privatekey');

var _privatekey2 = _interopRequireDefault(_privatekey);

var _utils = require('./utils');

var _basemodel = require('./basemodel.utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var tempEmitter = new _events.EventEmitter();
var eventEmmiterInternals = Object.getOwnPropertyNames(tempEmitter);

function build(extendEventEmitter) {
  var ParentClass = function ParentClass() {
    _classCallCheck(this, ParentClass);
  };

  if (extendEventEmitter) {
    ParentClass = _events.EventEmitter;
  }

  var AbstractBaseModel = function (_ParentClass) {
    _inherits(AbstractBaseModel, _ParentClass);

    /**
     * @classdesc Abstract Base Model representation for all created Document instances.
     * Represents just the document data and generic properties and functions.
     * Also used for "object" abstraction / representation of sub documents that are not actual Models / Documents.
     * Clients should never have to call this directly.
     *
     * @description Clients do not need to create <code>AbstractBaseModel</code> instances manually.
     * @class
     * @param {Object} values - the object data
     * @param {Object} options - creation options
     * @param {Boolean} options.clone - Whether to deep clone the incoming data. Default: <code>false</code>.
     *                                  Make sure you wish to do this as it has performance implications. This is
     *                                  useful if you are creating multiple instances from same base data and then
     *                                  wish to modify each instance.
     * @param {Schema} schema - schema instance
     * @returns {AbstractBaseModel}
     */
    function AbstractBaseModel(values, options, schema) {
      var _ret;

      _classCallCheck(this, AbstractBaseModel);

      // Object used to store internals.
      var _this = _possibleConstructorReturn(this, (AbstractBaseModel.__proto__ || Object.getPrototypeOf(AbstractBaseModel)).call(this));

      var _private = _this[_privatekey2.default] = {};

      // Object with getters and setters bound.
      _private._getset = _this;

      // Public version of ourselves.
      // Overwritten with proxy if available.
      _private._this = _this;

      // Object used to store raw values.
      _private._obj = {};

      _private.schema = schema;

      // Errors, retrieved with getErrors().
      _private._errors = [];

      // Define getters/typecasts based off of schema.
      _lodash2.default.each(schema.descriptor, function (properties, index) {
        // Use getter / typecast to intercept and re-route, transform, etc.
        _basemodel.defineProperty.call(_private._getset, index, properties);
      });

      // Proxy used as interface to object allows to intercept all access.
      // Without Proxy we must register individual getter/typecasts to put any logic in place.
      // With Proxy, we still use the individual getter/typecasts, but also catch values that aren't in the schema.
      if (typeof Proxy !== 'undefined') {
        var proxy = _this[_privatekey2.default]._this = new Proxy(_this, {
          // Ensure only public keys are shown
          ownKeys: function ownKeys(target) {
            return Object.keys(_this.toObject());
          },

          // Return keys to iterate
          enumerate: function enumerate(target) {
            return Object.keys(_this[_privatekey2.default]._this)[Symbol.iterator]();
          },

          // Check to see if key exists
          has: function has(target, key) {
            return Boolean(_private._getset[key]);
          },

          // Ensure correct prototype is returned.
          getPrototypeOf: function getPrototypeOf() {
            return _private._getset;
          },

          // Ensure readOnly fields are not writeable.
          getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, key) {
            return {
              value: proxy[key],
              writeable: !schema.descriptor[key] || schema.descriptor[key].readOnly !== true,
              enumerable: true,
              configurable: true
            };
          },

          // Intercept all get calls.
          get: function get(target, name, receiver) {
            // Support dot notation via lodash.
            if (schema.options.dotNotation && typeof name === 'string' && name.indexOf('.') !== -1) {
              return _lodash2.default.get(_this[_privatekey2.default]._this, name);
            }

            return Reflect.get(target, name, receiver);
            // Use registered getter without hitting the proxy to avoid creating an infinite loop.
            // return this[name];
          },

          // Intercept all set calls.
          set: function set(target, name, value, receiver) {
            // Support dot notation via lodash.
            if (schema.options.dotNotation && typeof name === 'string' && name.indexOf('.') !== -1) {
              _lodash2.default.set(_this[_privatekey2.default]._this, name, value);
              return true;
            }

            if (!schema.descriptor[name]) {
              // TODO revisit this
              if (extendEventEmitter && eventEmmiterInternals.indexOf(name) >= 0) {
                return true;
              }

              if (schema.options.strict) {
                // Strict mode means we don't want to deal with anything not in the schema.
                // TODO: SetterError here.
                return false;
              }

              // Add index to schema dynamically when value is set.
              // This is necessary for toObject to see the field.
              _this._addToSchema(name, {
                type: 'any'
              });
            }

            return Reflect.set(target, name, value, receiver);
            // This hits the registered setter but bypasses the proxy to avoid an infinite loop.
            // this[name] = value;
            // return true;
          },

          // Intercept all delete calls.
          deleteProperty: function deleteProperty(target, property) {
            _this[property] = undefined;
            return true;
          }
        });
      }

      // Populate schema defaults into object.
      _lodash2.default.each(schema.descriptor, function (properties, index) {
        if (properties.default !== undefined) {
          // Temporarily ensure readOnly is turned off to prevent the set from failing.
          var readOnly = properties.readOnly;
          properties.readOnly = false;
          _this[index] = _lodash2.default.isFunction(properties.default) ? properties.default.call(_this) : (0, _clone2.default)(properties.default);
          properties.readOnly = readOnly;
        }
      });

      // Populate runtime values as provided to this instance of object.
      if (_lodash2.default.isObject(values)) {
        var data = values;
        if (options.clone) {
          data = (0, _clone2.default)(values);
        }
        _this.set(data);
      }

      // May return actual object instance or Proxy, depending on harmony support.
      return _ret = _private._this, _possibleConstructorReturn(_this, _ret);
    }

    /**
     * Get the model schema instance
     * @public
     * @returns {Schema}
     */


    _createClass(AbstractBaseModel, [{
      key: '_addToSchema',


      // Add field to schema and initializes getter and setter for the field.
      value: function _addToSchema(index, properties) {
        this.schema.add(index, properties);
        _basemodel.defineProperty.call(this[_privatekey2.default]._getset, index, this.schema.descriptor[index]);
      }

      /**
       * Sets data on the document based on the schema.
       * Accepts a key of property and value for the property, or object representing the data for document.
       *
       * @public
       * @example
       * user.set('fistName', 'Joe');
       * user.set({ lastName: 'Smith' });
       */

    }, {
      key: 'set',
      value: function set(path, value) {
        if (_lodash2.default.isObject(path) && !value) {
          value = path;
          for (var key in value) {
            if (value.hasOwnProperty(key)) {
              try {
                this[_privatekey2.default]._this[key] = value[key];
              } catch (err) {}
            }
          }
        } else {
          try {
            this[_privatekey2.default]._this[path] = value;
          } catch (err) {}
        }
      }

      /**
       * Gets value at a specified path.
       * @param  {String} path The path / property to retrieve.
       * @return {*}      The value at the path.
       */

    }, {
      key: 'get',
      value: function get(path) {
        return this[path];
      }
    }, {
      key: '_prepareToObjectOptions',
      value: function _prepareToObjectOptions(options, json) {
        var schemaMinimizeOption = json ? 'toJSON' : 'toObject';

        var defaultMinimizeOption = this.schema.options && this.schema.options[schemaMinimizeOption] && _lodash2.default.isBoolean(this.schema.options[schemaMinimizeOption].minimize) ? this.schema.options[schemaMinimizeOption].minimize : true;

        var defaultOptions = {
          transform: true,
          json: json,
          minimize: defaultMinimizeOption
        };

        // When internally saving this document we always pass options,
        // bypassing the custom schema options.
        if (!(options && (0, _utils.getFunctionName)(options.constructor) === 'Object') || options && options._useSchemaOptions) {
          if (json) {
            options = this.schema.options.toJSON ? (0, _clone2.default)(this.schema.options.toJSON) : {};
            options.json = true;
            options._useSchemaOptions = true;
          } else {
            options = this.schema.options.toObject ? (0, _clone2.default)(this.schema.options.toObject) : {};
            options.json = false;
            options._useSchemaOptions = true;
          }
        }

        for (var key in defaultOptions) {
          if (defaultOptions.hasOwnProperty(key) && options[key] === undefined) {
            options[key] = defaultOptions[key];
          }
        }

        return options;
      }

      /**
       *
       * @param options
       * @param json
       * @returns {{}}
       * @private
       */

    }, {
      key: '_toObject',
      value: function _toObject(options, json) {
        var _this2 = this;

        options = this._prepareToObjectOptions(options, json);

        // remember the root transform function
        // to save it from being overwritten by sub-transform functions
        var originalTransform = options.transform;

        var ret = {};

        // Populate all properties in schema.
        _lodash2.default.each(this.schema.descriptor, function (properties, index) {
          // Do not write values to object that are marked as invisible.
          if (properties.invisible && !properties.virtual) {
            return;
          }

          if (properties.virtual && !options.virtuals) {
            return;
          }

          if (properties.serializable === false && options.serializable === false) {
            return;
          }

          // Fetch value through the public interface.
          var value = _this2[_privatekey2.default]._this[index];

          if (options.minimize && (_lodash2.default.isUndefined(value) || _lodash2.default.isNull(value))) {
            return;
          }

          // Clone objects so they can't be modified by reference.
          if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value) {
            if (value._isBaseModel) {
              if (options && options.json && typeof value.toJSON === 'function') {
                value = value.toJSON(options);
              } else {
                value = value.toObject(options);
              }
            } else if (value._isObjectArray) {
              value = value.toArray();
            } else if (_lodash2.default.isArray(value)) {
              value = value.splice(0);
            } else if (_lodash2.default.isDate(value)) {
              // https://github.com/documentcloud/underscore/pull/863
              // _.clone doesn't work on Date object.
              var d = new Date(value.getTime());
              if (options.dateToISO === true) {
                ret[index] = d.toISOString();
              } else {
                ret[index] = new Date(value.getTime());
              }
            } else {
              value = _lodash2.default.clone(value);
            }

            // Don't write empty objects or arrays.
            if (!_lodash2.default.isDate(value) && options.minimize && !_lodash2.default.size(value)) {
              return;
            }
          }

          // Write to object.
          ret[index] = value;
        });

        var transform = options.transform;

        // In the case where a subdocument has its own transform function, we need to
        // check and see if the parent has a transform (options.transform) and if the
        // child schema has a transform (this.schema.options.toObject) In this case,
        // we need to adjust options.transform to be the child schema's transform and
        // not the parent schema's
        if (transform === true || this.schema.options.toObject && transform) {
          var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;

          if (opts) {
            transform = typeof options.transform === 'function' ? options.transform : opts.transform;
          }
        } else {
          options.transform = originalTransform;
        }

        if (typeof transform === 'function') {
          var xformed = transform(this, ret, options);
          if (typeof xformed !== 'undefined') {
            ret = xformed;
          }
        }

        return ret;
      }

      /**
       * Converts this document into a plain javascript object.
       *
       * @public
       * @param {Object} options
       * @param {Function} options.transform - a transform function to apply to the resulting document before returning.
       * @param {Boolean} options.virtuals - apply virtual getters. Default: <code>false</code>
       * @param {Boolean} options.minimize - remove empty objects. Default: <code>true</code>
       * @param {Boolean} options.serializable - whether to include <code>serializable</code> properties. Default: <code>true</code>
       * @param {Boolean} options.dateToISO - convert dates to string in ISO format using <code>Date.toISOString()</code>. Default: <code>true</code>
       *
       * @return {Object} Plain javascript object representation of document.
       *
       * @example
       * var userSchema = lounge.schema({ name: String });
       * var User = lounge.model('User', userSchema);
       * var user = new User({name: 'Joe Smith'});
       * console.log(user); // automatically invokes toObject()
       *
       * @example <caption>Example with transform option.</caption>
       * var xform = function (doc, ret, options) {
       *   ret.name = ret.name.toUpperCase();
       *   return ret;
       * };
       * console.dir(user.toObject({transform: xform}); // { name: 'JOE SMITH' }
       */

    }, {
      key: 'toObject',
      value: function toObject(options) {
        return this._toObject(options);
      }

      /**
       * Similar as <code>toObject</code> but applied when <code>JSON.stringify</code> is called
       *
       * @public
       * @param {Object} options - Same options as <code>toObject</code>.
       * @return {Object} Plain javascript object representation of document.
       */

    }, {
      key: 'toJSON',
      value: function toJSON(options) {
        return this._toObject(options, true);
      }

      /**
       * Helper for <code>console.log</code>. Just invokes default <code>toObject</code>.
       * @public
       */

    }, {
      key: 'inspect',
      value: function inspect() {
        return this.toObject({});
      }

      /**
       * Helper for <code>console.log</code>. Alias for <code>inspect</code>.
       * @public
       */

    }, {
      key: 'toString',
      value: function toString() {
        return (0, _util.inspect)(this.inspect());
      }

      /**
       * Clear the document data. This can be overridden at schema level using <code>Schema.set()</code>.
       */

    }, {
      key: 'clear',
      value: function clear() {
        var _this3 = this;

        _lodash2.default.each(this.schema.descriptor, function (properties, index) {
          _basemodel.clearField.call(_this3[_privatekey2.default]._this, index, properties);
        });
      }

      /**
       * Gets the errors object.
       */

    }, {
      key: 'getErrors',
      value: function getErrors() {
        return this[_privatekey2.default]._errors;
      }

      /**
       * Clears all the errors.
       */

    }, {
      key: 'clearErrors',
      value: function clearErrors() {
        this[_privatekey2.default]._errors.length = 0;
      }

      /**
       * Checks whether we have any errors.
       * @return {Boolean} <code>true</code> if we have errors, <code>false</code> otherwise.
       */

    }, {
      key: 'hasErrors',
      value: function hasErrors() {
        return Boolean(this[_privatekey2.default]._errors.length);
      }

      /**
       * Used to detect instance of schema object internally.
       * @private
       */

    }, {
      key: '_isBaseModel',
      value: function _isBaseModel() {
        return true;
      }
    }, {
      key: 'schema',
      get: function get() {
        return this[_privatekey2.default].schema;
      }
    }]);

    return AbstractBaseModel;
  }(ParentClass);

  return AbstractBaseModel;
}

/**
 * @classdesc BaseModel implements <code>AbstractBaseModel</code> and is a representation for all created Document
 * instances that have a user defined schema. Represents just the document data and generic properties and functions.
 * Clients should never have to call this directly. Inherits <code>EventEmitter</code>
 *
 * @description Clients do not need to create <code>BaseModel</code> instances manually.
 * @class
 * @augments EventEmitter
 */
var BaseModel = build(true);

/**
 * @classdesc PlainBaseModel implements <code>AbstractBaseModel</code> and is a representation for embedded subdocument
 * objects within user defined models. Clients should never have to call this directly.
 *
 * @description Clients do not need to create <code>PlainBaseModel</code> instances manually.
 * @class
 */
var PlainBaseModel = build();

exports.BaseModel = BaseModel;
exports.PlainBaseModel = PlainBaseModel;