'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Model = undefined;
exports.compile = compile;

var _events = require('events');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _grapplingHook = require('grappling-hook');

var _grapplingHook2 = _interopRequireDefault(_grapplingHook);

var _inflection = require('inflection');

var _inflection2 = _interopRequireDefault(_inflection);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _basemodel = require('./basemodel');

var _schema = require('./schema');

var _schema2 = _interopRequireDefault(_schema);

var _cbdocument = require('./cbdocument');

var _cbdocument2 = _interopRequireDefault(_cbdocument);

var _privatekey = require('./privatekey');

var _privatekey2 = _interopRequireDefault(_privatekey);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @name Model
 * @classdesc Model class is a base class for all <code>ModelInstances</code> and it extends <code>CouchbaseDocument</code>
 * @description Model class is a base class for all <code>ModelInstances</code> and it extends <code>CouchbaseDocument</code>
 * @class
 * @augments CouchbaseDocument
 */
var Model = exports.Model = function (_CouchbaseDocument) {
  _inherits(Model, _CouchbaseDocument);

  function Model() {
    _classCallCheck(this, Model);

    return _possibleConstructorReturn(this, (Model.__proto__ || Object.getPrototypeOf(Model)).apply(this, arguments));
  }

  return Model;
}(_cbdocument2.default);

/**
 * Compiles a schema into a Model
 * @param schema
 * @param options
 * @returns {ObjectInstance}
 * @private
 */

function compilePlainObject(schema, options) {
  var PlainModelInstance = function (_PlainBaseModel) {
    _inherits(PlainModelInstance, _PlainBaseModel);

    function PlainModelInstance(data) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, PlainModelInstance);

      return _possibleConstructorReturn(this, (PlainModelInstance.__proto__ || Object.getPrototypeOf(PlainModelInstance)).call(this, data, options, schema));
    }

    return PlainModelInstance;
  }(_basemodel.PlainBaseModel);

  PlainModelInstance.schema = schema;

  // if the user wants to allow modifications
  if (options.freeze !== false) {
    Object.freeze(PlainModelInstance);
  }

  return PlainModelInstance;
}

/**
 * Compiles a descriptor into an <code>PlainModelInstance</code> or <code>ModelInstance</code>
 * @param {Schema|Object} descriptor - the schema or schema descriptor. If <code>Object</code> we create a new schema and
 *                                     create an <code>PlainModelInstance</code>, otherwise we create a <code>ModelInstance</code>
 * @param {Object} options - Schema creation options
 * @param {String|undefined} name - the name of the model
 * @param {Driver|null} db - the database driver
 * @param {Object} config - the config
 * @returns {PlainModelInstance|ModelInstance}
 * @private
 */
function compile(descriptor) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  var lounge = arguments[3];

  // Some of the options require the reflection.
  if (typeof Proxy === 'undefined') {
    // If strict mode is off but the --harmony flag is not, fail.
    if (!options.strict) {
      throw new Error('Turning strict mode off requires --harmony flag.');
    }

    // If dot notation is on but the --harmony flag is not, fail.
    if (options.dotNotation) {
      throw new Error('Dot notation support requires --harmony flag.');
    }
  }

  var schema = descriptor;
  if (!(schema instanceof _schema2.default)) {
    schema = new _schema2.default(schema, options);
    return compilePlainObject(schema, options);
  }

  var db = lounge ? lounge.db : null;
  var config = lounge ? lounge.config : null;

  /**
   * ModelInstance class is the compiled class from a schema definition. It extends <code>Model</code>.
   * All models generated are an instance of <code>ModelInstance</code>. It also inherits <code>grappling-hook</code>
   * See {@link https://www.github.com/bojand/grappling-hook grappling-hook} for pre and post hooks.
   * @class
   * @augments Model
   *
   */

  var ModelInstance = function (_Model) {
    _inherits(ModelInstance, _Model);

    /**
     * This would be the constructor for the generated models.
     * @param {Object} data - the model instance data
     * @param {Object} options - optional creation options
     * @param {Boolean} options.clone - Whether to deep clone the incoming data. Default: <code>false</code>.
     *                                  Make sure you wish to do this as it has performance implications. This is
     *                                  useful if you are creating multiple instances from same base data and then
     *                                  wish to modify each instance.
     * @param {Object} cas - the Couchbase <code>CAS</code> value
     */
    function ModelInstance(data) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var cas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

      _classCallCheck(this, ModelInstance);

      var _this3 = _possibleConstructorReturn(this, (ModelInstance.__proto__ || Object.getPrototypeOf(ModelInstance)).call(this, data, cas, options, schema, name));

      _this3[_privatekey2.default].lounge = lounge;
      _this3[_privatekey2.default].db = db || ModelInstance.db;
      _this3[_privatekey2.default].config = config || ModelInstance.config;
      return _this3;
    }

    return ModelInstance;
  }(Model);

  // inherit EventEmitter into the ModelInstance for ModelInstance-scoped events


  ModelInstance.emitter = new _events.EventEmitter();
  ['listenerCount', 'addListener', 'emit', 'getMaxListeners', 'listenerCount', 'listeners', 'on', 'once', 'removeAllListeners', 'removeListener', 'setMaxListeners'].forEach(function (key) {
    ModelInstance[key] = function () {
      var _ModelInstance$emitte;

      (_ModelInstance$emitte = ModelInstance.emitter)[key].apply(_ModelInstance$emitte, arguments);
    };
  });

  /**
   * @name schema
   * @static {Schema}
   * @memberof ModelInstance
   * @description Schema the schema of this model.
   */
  ModelInstance.schema = schema;

  /**
   * @name modelName
   * @static {String}
   * @memberof ModelInstance
   * @description The name of the model.
   */
  ModelInstance.modelName = name;

  /**
   * @name db
   * @static {Driver}
   * @memberof ModelInstance
   * @description The driver.
   */
  Object.defineProperty(ModelInstance, 'db', {
    enumerable: true,
    configurable: false,
    get: function get() {
      return ModelInstance._private.db;
    }
  });

  Object.defineProperty(ModelInstance, '_private', {
    enumerable: false,
    configurable: false,
    writable: false,
    value: { db: db }
  });

  /**
   * @name config
   * @static {Object}
   * @memberof ModelInstance
   * @description The config.
   */
  ModelInstance.config = config;

  // Add custom methods to generated class.
  _lodash2.default.each(schema.methods, function (method, key) {
    if (ModelInstance.prototype[key]) {
      throw new Error('Cannot overwrite existing ' + key + ' method with custom method.');
    }
    ModelInstance.prototype[key] = method;
  });

  // Add custom static methods to generated class.
  _lodash2.default.each(schema.statics, function (method, key) {
    if (ModelInstance[key]) {
      throw new Error('Cannot overwrite existing ' + key + ' static with custom method.');
    }
    ModelInstance[key] = method;
  });

  _grapplingHook2.default.attach(ModelInstance, {
    createThenable: function createThenable(fn) {
      return new _bluebird2.default(fn);
    },
    attachToPrototype: true
  });

  setupHooks(ModelInstance, config);

  setupIndexFunctions(ModelInstance);

  setupOverrides(ModelInstance);

  // if the user wants to allow modifications
  if (options.freeze !== false) {
    Object.freeze(ModelInstance);
  }

  return ModelInstance;
}

/*!
 * Sets up hooks for the new Model
 * @param InstanceModel
 */
function setupHooks(InstanceModel, config) {
  var ourHookedFnNames = ['save', 'remove', 'index'];
  var schema = InstanceModel.schema;
  var hooks = _lodash2.default.values(schema.hooks);

  _lodash2.default.forEach(hooks, function (ho) {
    var addHookFn = 'addDynamicHooks';
    if (!config.promisify) {
      addHookFn = 'addFlexibleHooks';
    }
    InstanceModel.prototype[addHookFn](ho.name);
    var mwopts = { passParams: true };
    _lodash2.default.forEach(ho.fns, function (fn, index) {
      if (ourHookedFnNames.indexOf(ho.name) >= 0) {
        var mwFn = fn;
        if (ho.hook === 'post') {
          ho.fns[index] = function (next) {
            mwFn.apply(this);
            next();
          };
        }

        mwopts.passParams = false;
      }
    });
    InstanceModel.prototype[ho.hook](ho.name, ho.fns, mwopts);
  });
}

function generateIndexFinder(InstanceModel, path, name) {
  if (Array.isArray(path)) {

    return function indexFind() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var fn;

      if (!args || args.length <= path.length) {
        fn = args.splice(-1);
        return process.nextTick(fn);
      }

      var params = args.splice(0, path.length);
      var options = args.splice(0, 1)[0];

      if (args && args.length > 0) {
        fn = args.splice(0, 1)[0];
      } else {
        fn = options;
        options = {};
      }

      if (!fn) {
        fn = _lodash2.default.noop;
      }

      var param = params.join('_');

      var docKey = this.schema.getRefKey(name, param);
      return InstanceModel._findByIndexValue(docKey, path, options, fn);
    };
  } else {
    return function indexFind(param, options, fn) {
      if (!param) {
        return process.nextTick(fn);
      }

      var docKey = this.schema.getRefKey(name, param);
      return InstanceModel._findByIndexValue(docKey, path, options, fn);
    };
  }
}

/*!
 * Sets up index query functions
 * @param InstanceModel
 */
function setupIndexFunctions(InstanceModel) {
  if (InstanceModel && InstanceModel.schema && InstanceModel.schema.indexes) {
    var indexes = InstanceModel.schema.indexes;
    var v = void 0;
    for (v in indexes) {
      if (indexes.hasOwnProperty(v)) {
        (function () {
          var path = indexes[v].path;
          var name = indexes[v].name;
          var fnName = 'findBy'.concat(_inflection2.default.camelize(_inflection2.default.underscore(name)));
          var indexFind = generateIndexFinder(InstanceModel, path, name);
          InstanceModel[fnName] = function () {
            return _utils.promisifyCall.apply(undefined, [this, indexFind].concat(Array.prototype.slice.call(arguments)));
          };
        })();
      }
    }
  }
}

var overridableMethods = ['clear'];

function setupOverrides(ModelInstance) {
  var schema = ModelInstance.schema;
  _lodash2.default.forEach(overridableMethods, function (m) {
    var so = schema.get(m);
    if (_lodash2.default.isFunction(so)) {
      ModelInstance.prototype[m] = so;
    }
  });
}