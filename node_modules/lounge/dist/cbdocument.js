'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _async = require('async');

var _async2 = _interopRequireDefault(_async);

var _mpath = require('mpath');

var _mpath2 = _interopRequireDefault(_mpath);

var _clone = require('clone');

var _clone2 = _interopRequireDefault(_clone);

var _memodriver = require('./memodriver');

var _memodriver2 = _interopRequireDefault(_memodriver);

var _cbdocumentUtils = require('./cbdocument.utils.js');

var cdocUtils = _interopRequireWildcard(_cbdocumentUtils);

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

var _schemaUtils = require('./schema.utils.js');

var schemaUtils = _interopRequireWildcard(_schemaUtils);

var _document = require('./document');

var _document2 = _interopRequireDefault(_document);

var _privatekey = require('./privatekey');

var _privatekey2 = _interopRequireDefault(_privatekey);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var debug = require('debug')('lounge');

var DIGIT_REGEX = /^\d+$/;

var CouchbaseDocument = function (_Document) {
  _inherits(CouchbaseDocument, _Document);

  /**
   * @classdesc CouchbaseDocument inherits Document and handles all the database related actions.
   * Clients should never have to call this directly.
   *
   * @description Clients do not need to create Document manually.
   * @class
   * @augments Document
   * @param {Object} values - the object data
   * @param {Object} cas - the Couchbase <code>CAS</code> value for the document
   * @param {Object} options - creation options
   * @param {Boolean} options.clone - Whether to deep clone the incoming data. Default: <code>false</code>.
   *                                  Make sure you wish to do this as it has performance implications. This is
   *                                  useful if you are creating multiple instances from same base data and then
   *                                  wish to modify each instance.
   * @param {Schema} schema - schema instance
   * @param {String} name - the model name
   * @returns {CouchbaseDocument}
   */
  function CouchbaseDocument(values, cas, options, schema, name) {
    _classCallCheck(this, CouchbaseDocument);

    var _this = _possibleConstructorReturn(this, (CouchbaseDocument.__proto__ || Object.getPrototypeOf(CouchbaseDocument)).call(this, values, options, schema, name));

    _this[_privatekey2.default].cas = cas;

    _this[_privatekey2.default]._o = {
      refValues: {},
      key: null
    };

    _lodash2.default.merge(_this[_privatekey2.default]._o.refValues, cdocUtils.buildRefValues(_this.schema.indexes, values));
    _this[_privatekey2.default]._o.key = _this.getDocumentKeyValue();
    return _this;
  }

  /**
   * Returns the string representation of <code>CAS</code> value.
   * @example
   * console.log(doc.cas); // String: 00000000a71626e4
   * @returns {String}
   */


  _createClass(CouchbaseDocument, [{
    key: 'getCAS',


    /**
     * Returns the document <code>CAS</code> value.
     * @param {Boolean} raw - If <code>true</code> returns the raw CAS document. If <code>false</code> returns string
     *                        representation of CAS. Defaults to <code>false</code>.
     * @returns {String|Object} the CAS value
     * @example
     * console.log(doc.getCAS()); // String: 00000000a71626e4
     * console.log(doc.getCAS(true)); // Object: CouchbaseCas<11338961768815788032>
     */
    value: function getCAS(raw) {
      if (raw) {
        return this[_privatekey2.default].cas;
      }

      var v = '';
      var cas = this[_privatekey2.default].cas;

      if ((typeof cas === 'undefined' ? 'undefined' : _typeof(cas)) === 'object') {
        var p = void 0;
        for (p in cas) {
          if (cas.hasOwnProperty(p) && cas[p]) {
            if (Buffer.isBuffer(cas[p])) {
              v = v.concat(cas[p].toString('hex'));
            } else {
              v = v.concat(cas[p].toString());
            }
          }
        }
      }

      if (cas && (!v || !v.trim().length)) {
        v = cas.toString();
      }

      return v;
    }

    /**
     * Save the current model instance. Calls db set function for the model id and saves the properties.
     * @param {Object} options The save options. All options not present here are first looked up from schema options,
     * and then from config options.
     * @param {Boolean} options.storeFullReferenceId - whether to save embedded document property values as full document keys or just the base value
     * @param {Boolean} options.storeFullKey - whether to save the internal document key property as fully expanded value or as the simple value
     * @param {String} options.refIndexKeyPrefix - lookup index document key prefix.
     * @param {Boolean} options.waitForIndex - whether we want to wait for indexing to finish before returning. Default: <code>false</code>.
     * @param {Boolean} options.virtuals - whether we want to save virtuals. Default: <code>false</code>.
     * @param {Boolean} options.minimize - to "minimize" the document by removing any empty properties. Default: <code>true</code>
     * @param {Number} options.expiry - couchbase upsert option
     * @param {Number} options.persist_to - couchbase persist_to option
     * @param {Number} replicate_to - couchbase option
     * @param {Function} fn callback
     * @example
     * var user = new User({ name: 'Bob Smith', email: 'bsmith@acme.com' });
     * user.save(function(err, savedDoc) {
     *   if(err) console.log(err);
     * });
     */

  }, {
    key: 'save',
    value: function save(options, fn) {
      return utils.promisifyCall.apply(utils, [this, this._saveImpl].concat(Array.prototype.slice.call(arguments)));
    }
  }, {
    key: '_saveImpl',
    value: function _saveImpl(options, fn) {
      var _this2 = this;

      if (typeof options === 'function') {
        fn = options;
        options = {};
      }

      if (!fn) {
        fn = _lodash2.default.noop;
      }

      options = _lodash2.default.defaults(options || {}, _lodash2.default.pick(this.schema.options, utils.saveOptionsKeys), _lodash2.default.pick(this.config, utils.saveOptionsKeys));

      if (process.env.LOUNGE_DEBUG_FORCE_SAVE_FAIL) {
        return process.nextTick(function () {
          return fn(new Error('Forced save error'));
        });
      }

      var changedRefs = [];

      // iteratively save the refs
      var refs = this._getSortedRefPaths(true);
      if (refs && refs.length > 0) {
        _async2.default.eachLimit(refs, 20, function (path, eachCB) {
          _this2._saveRef(path, changedRefs, options, eachCB);
        }, function (err) {
          if (err) {
            _this2._broadcast('error', err, _this2);
            return fn(err);
          }
          _this2._indexAndSave(changedRefs, options, fn);
        });
      } else {
        this._indexAndSave(changedRefs, options, fn);
      }
    }

    /*!
     * Save the ref at path
     * @param path
     * @param fn
     */

  }, {
    key: '_saveRef',
    value: function _saveRef(path, changedRefs, options, fn) {
      var _this3 = this;

      var thing = _mpath2.default.get(path, this);

      if (_lodash2.default.isUndefined(thing) || _lodash2.default.isNull(thing)) {
        return fn();
      }

      if (!_lodash2.default.isArray(thing)) {
        if (thing instanceof CouchbaseDocument) {
          changedRefs.push({
            path: path,
            value: thing
          });
        }

        this._saveRefField(path, thing, options, function (err, savedRefDoc) {
          if (err) {
            return fn(err);
          }

          if (savedRefDoc instanceof CouchbaseDocument) {
            var strValue = savedRefDoc.getDocumentKeyValue(_this3.config.storeFullReferenceId);
            _mpath2.default.set(path, strValue, _this3);
            if (_lodash2.default.isPlainObject(thing)) {
              changedRefs.push({
                path: path,
                value: savedRefDoc
              });
            }
          }
          return fn(err, savedRefDoc);
        });
      } else if (_lodash2.default.isArray(thing)) {
        var idArray = [];
        _async2.default.forEachOfLimit(thing, 10, function (thingDoc, key, arrayCB) {
          if (thingDoc instanceof CouchbaseDocument) {
            changedRefs.push({
              path: path.concat('.', key),
              value: thingDoc
            });
          }

          _this3._saveRefField(path, thingDoc, options, function (err, savedRefDoc) {
            if (err) {
              return arrayCB(err);
            }
            if (savedRefDoc instanceof CouchbaseDocument) {
              var strValue = savedRefDoc.getDocumentKeyValue(_this3.config.storeFullReferenceId);
              idArray.push(strValue);
              if (_lodash2.default.isPlainObject(thingDoc)) {
                changedRefs.push({
                  path: path.concat('.', key),
                  value: savedRefDoc
                });
              }
            }
            return arrayCB(err);
          });
        }, function (err) {
          if (!err) {
            _mpath2.default.set(path, idArray, _this3);
          }
          return fn(err);
        });
      }
    }

    /*!
     * Indexes this instance and saves it afterwards
     * @param changedRefs
     * @param options
     * @param fn callback
     */

  }, {
    key: '_indexAndSave',
    value: function _indexAndSave(changedRefs, options, fn) {
      var _this4 = this;

      if (options.waitForIndex === true || _lodash2.default.isUndefined(options.waitForIndex) && this.config.waitForIndex === true) {
        this.index(options, function (err) {
          if (err) {
            _this4._broadcast('error', err, _this4);
            return fn(err);
          }

          return _this4._save(changedRefs, options, fn);
        });
      } else {
        this.index(options);
        return this._save(changedRefs, options, fn);
      }
    }

    /*!
     * Saves this instance
     * @param changedRefs
     * @param options
     * @param fn
     */

  }, {
    key: '_save',
    value: function _save(changedRefs, options, fn) {
      var _this5 = this;

      var toObjectOpts = {
        expandDocumentKey: options.storeFullKey || this.config.storeFullKey,
        virtuals: false,
        transform: false,
        minimize: options.minimize,
        dateToISO: true,
        serializable: false
      };

      var doc = this.toObject(toObjectOpts);
      var id = this.getDocumentKeyValue(true);

      var opts = _lodash2.default.pick(options || {}, ['cas', 'expiry', 'persist_to', 'replicate_to']);

      debug('save. type: ' + this.modelName + '  key: ' + id);

      this.db.upsert(id, doc, opts, function (err, res) {
        if (changedRefs && changedRefs.length > 0) {
          changedRefs.forEach(function (cr) {
            _mpath2.default.set(cr.path, cr.value, _this5);
          });
        }

        delete _this5[_privatekey2.default].cas;
        _this5[_privatekey2.default].cas = res.cas;

        delete _this5[_privatekey2.default]._o.refValues;
        _this5[_privatekey2.default]._o.refValues = {};
        _lodash2.default.merge(_this5[_privatekey2.default]._o.refValues, cdocUtils.buildRefValues(_this5.schema.indexes, _this5));

        if (!err) {
          _this5._broadcast('save', _this5, options);
        }

        return fn(err, _this5);
      });
    }

    /**
     * Update all lookup documents for this document instance. Creates new lookup documents for properties that have changed
     * and deletes the old ones not needed any more.
     * @param {Object} options
     * @param {Boolean} options.storeFullReferenceId - whether we store full document id in reference documents
     * @param {Boolean} options.atomicLock - whether to use atomicLock
     * @param {Function} fn callback
     */

  }, {
    key: 'index',
    value: function index(options, fn) {
      return utils.promisifyCall.apply(utils, [this, this._index].concat(Array.prototype.slice.call(arguments)));
    }
  }, {
    key: '_index',
    value: function _index(options, fn) {
      var _this6 = this;

      var defaults = {
        storeFullReferenceId: _lodash2.default.isUndefined(this.schema.options.storeFullReferenceId) ? this.config.storeFullReferenceId : this.schema.options.storeFullReferenceId,
        atomicLock: this.config.atomicLock
      };

      if (typeof options === 'function') {
        fn = options;
        options = defaults;
      }

      if (!fn || typeof fn !== 'function') {
        fn = _lodash2.default.noop;
      }

      options = _lodash2.default.defaults(options || {}, defaults);

      var currentRefValues = cdocUtils.buildRefValues(this.schema.indexes, this);

      var fieldsToRef = cdocUtils.buildIndexObjects(this[_privatekey2.default]._o.refValues, currentRefValues);

      _async2.default.eachLimit(fieldsToRef, 20, function (refObj, eaCb) {
        _this6._indexField(refObj, options, eaCb);
      }, function (err) {
        if (!err) {
          _this6._broadcast('index', _this6, options);
        }
        return fn(err);
      });
    }

    /*!
     * Index document field
     */

  }, {
    key: '_indexField',
    value: function _indexField(obj, options, fn) {
      var _this7 = this;

      if (typeof options === 'function') {
        fn = options;
        options = {};
      }

      if (!fn) {
        fn = _lodash2.default.noop;
      }

      if (!obj.value) {
        return process.nextTick(fn);
      }

      var docKey = this.schema.getRefKey(obj.name, obj.value);
      var refKeyValue = this.getDocumentKeyValue(_lodash2.default.isUndefined(options.storeFullReferenceId) ? this.config.storeFullReferenceId : options.storeFullReferenceId);

      if (obj.indexType === 'array') {
        debug('array index. operation: ' + obj.action + ' key: ' + docKey + ' refKeyValue: ' + refKeyValue);
        var indexTranform = cdocUtils.generateIndexTransform(obj, refKeyValue);
        this.db.atomic(docKey, indexTranform, { atomicLock: options.atomicLock }, function (err, indexDoc) {
          if (err) {
            _this7._broadcast('error', err, _this7);
            return fn(err);
          }

          return fn(err, indexDoc);
        });
      } else {
        var _db;

        var args = obj.action === 'remove' ? [docKey, fn] : [docKey, {
          key: refKeyValue
        }, fn];

        debug('single index. operation: ' + obj.action + ' key: ' + docKey + ' refKeyValue: ' + refKeyValue);

        return (_db = this.db)[obj.action].apply(_db, args);
      }
    }
  }, {
    key: '_getSortedRefPaths',
    value: function _getSortedRefPaths(reverse) {
      var refs = [];

      if (this.schema.refs) {
        for (var key in this.schema.refs) {
          if (this.schema.refs.hasOwnProperty(key)) {
            refs.push(this.schema.refs[key].path);
          }
        }

        if (refs.length > 0) {
          refs = _lodash2.default.sortBy(refs, 'length');
          if (reverse) {
            refs.reverse();
          }
        }
      }

      return refs;
    }

    /*!
     * Gers the model at a reference path
     * @param {String} path
     * @returns {*}
     */

  }, {
    key: '_getRefModel',
    value: function _getRefModel(path) {
      var model = void 0;
      if (this.schema.refs) {
        var modelName = this.schema.refs[path].ref;
        if (modelName) {
          model = this[_privatekey2.default].lounge.models[modelName];
        }
      }

      return model;
    }

    /*!
     * Save embedded document field at a path
     * @param doc
     * @param path
     * @param thing
     * @param options
     * @param fn
     * @returns {*}
     */

  }, {
    key: '_saveRefField',
    value: function _saveRefField(path, thing, options, fn) {
      function saveRefDoc(couchDoc) {
        var _this8 = this;

        couchDoc.save(options, function (err, savedDoc) {
          if (err) {
            _this8._broadcast('error', err, couchDoc);
            fn(err);
          } else {
            fn(null, couchDoc);
          }
        });
      }

      if (thing instanceof CouchbaseDocument) {
        saveRefDoc(thing);
      } else if (_lodash2.default.isString(thing)) {
        return process.nextTick(fn);
      } else if (utils.isPlainObject(thing)) {
        var RefModel = this._getRefModel(path);
        if (RefModel) {
          var instance = new RefModel(thing);
          saveRefDoc(instance);
        } else {
          console.error('ref at path \'%s\' is not a couchbase document and cannot fetch a ref model for it', path);
        }
      }
    }

    /**
     * Removes the instance from the database.
     * Calls the bucket <code>remove()</code> function. Options can be passed to the driver.
     * @param {Object} options Options to be passed to the Couchbase `Bucket.remove()` function.
     * @param {Function} fn callback
     * @example
     * user.remove(function(err, doc) {
     *   if(err) console.log(err);
     * });
     */

  }, {
    key: 'remove',
    value: function remove(options, fn) {
      return utils.promisifyCall.apply(utils, [this, this._removeImpl].concat(Array.prototype.slice.call(arguments)));
    }
  }, {
    key: '_removeImpl',
    value: function _removeImpl(options, fn) {
      var _this9 = this;

      if (typeof options === 'function') {
        fn = options;
        options = {};
      }

      if (!fn) {
        fn = _lodash2.default.noop;
      }

      if (!options) {
        options = {};
      }

      if (process.env.LOUNGE_DEBUG_FORCE_REMOVE_FAIL) {
        return process.nextTick(function () {
          return fn(new Error('Forced remove error'));
        });
      }

      if (options.removeRefs === true) {
        var refs = this._getSortedRefPaths(true);
        if (refs && refs.length > 0) {
          _async2.default.eachLimit(refs, 20, function (path, eachCB) {
            var thing = _mpath2.default.get(path, _this9);

            if (_lodash2.default.isUndefined(thing) || _lodash2.default.isNull(thing)) {
              return eachCB();
            }

            if (!_lodash2.default.isArray(thing)) {
              return _this9._removeRefField(_this9, path, thing, options, eachCB);
            } else if (_lodash2.default.isArray(thing)) {
              var idArray = [];
              _async2.default.forEachOfLimit(thing, 20, function (thingDoc, key, arrayCB) {
                _this9._removeRefField(idArray, path, thingDoc, options, arrayCB);
              }, eachCB);
            } else {
              eachCB();
            }
          }, function (err) {
            if (err) {
              _this9._broadcast('error', err, _this9);
              return fn(err);
            }

            _this9._remove(options, fn);
          });
        } else {
          this._remove(options, fn);
        }
      } else {
        this._remove(options, fn);
      }
    }

    /*!
     * Remove embedded document at a path
     * @param doc
     * @param path
     * @param thing
     * @param options
     * @param fn
     * @returns {*}
     */

  }, {
    key: '_removeRefField',
    value: function _removeRefField(doc, path, thing, options, fn) {
      var _this10 = this;

      if (thing instanceof CouchbaseDocument) {
        return thing.remove(options, fn);
      }

      var RefModel = this._getRefModel(path);

      if (RefModel && thing) {
        if (_lodash2.default.isString(thing)) {
          RefModel._findById(thing, {}, null, function (err, doc) {
            if (err) {
              _this10._broadcast('error', err, _this10);
              return fn(err);
            } else if (doc) {
              return doc.remove(options, fn);
            }

            return fn();
          });
        } else if (utils.isPlainObject(thing)) {
          var instance = new RefModel(thing);
          return instance.remove(options, fn);
        } else {
          console.error('ref at path \'%s\' is not a couchbase document and cannot fetch a ref model for it', path);
          return fn();
        }
      } else {
        console.error('ref at path \'%s\' is not a couchbase document and cannot fetch a ref model for it', path);
        return fn();
      }
    }

    /*!
     * Remove this document from database. Removes all index documents.
     * @param options
     * @param fn
     */

  }, {
    key: '_remove',
    value: function _remove(options, fn) {
      var _this11 = this;

      var opts = _lodash2.default.pick(options || {}, ['cas', 'persist_to', 'replicate_to']);
      var key = this.getDocumentKeyValue(true);

      debug('remove. key: ' + key);

      this.db.remove(key, opts, function (err) {
        if (err) {
          _this11._broadcast('error', err, _this11);
          console.error('%s.$remove err: %j', _this11.modelName, err);
        } else {
          _this11._broadcast('remove', _this11, options);
          _this11.removeIndexes(options);
        }

        return fn(err, _this11);
      });
    }

    /**
     * Removes all lookup / index documents for this document.
     * @param {Object} options
     * @param {Boolean} options.storeFullReferenceId - whether we store full document id in reference documents
     * @param {Function} fn callback
     */

  }, {
    key: 'removeIndexes',
    value: function removeIndexes(options, fn) {
      return utils.promisifyCall.apply(utils, [this, this._removeIndexes].concat(Array.prototype.slice.call(arguments)));
    }
  }, {
    key: '_removeIndexes',
    value: function _removeIndexes(options, fn) {
      var _this12 = this;

      var defaults = {
        storeFullReferenceId: _lodash2.default.isUndefined(this.schema.options.storeFullReferenceId) ? this.config.storeFullReferenceId : this.schema.options.storeFullReferenceId
      };

      if (typeof options === 'function') {
        fn = options;
        options = defaults;
      }

      if (!fn || typeof fn !== 'function') {
        fn = _lodash2.default.noop;
      }

      options = _lodash2.default.defaults(options || {}, defaults);

      var currentRefValues = cdocUtils.buildRefValues(this.schema.indexes, this);

      var toRemove = _lodash2.default.union(_lodash2.default.values(currentRefValues), _lodash2.default.values(this[_privatekey2.default]._o.refValues));

      // flatten arrays
      var toRemove2 = [];
      toRemove.forEach(function (e) {
        if (typeof e.value === 'string' || typeof e.value === 'number') {
          toRemove2.push(e);
        } else if (Array.isArray(e.value)) {
          e.value.forEach(function (ve) {
            toRemove2.push({
              path: e.path,
              name: e.name,
              indexType: e.indexType,
              value: ve
            });
          });
        }
      });

      // uniq
      var uniq = _lodash2.default.uniqWith(toRemove2, function (arrVal, otherVal) {
        var v1 = ''.concat(arrVal.path || '', arrVal.value || '', arrVal.name || '', arrVal.indexType || '');
        var v2 = ''.concat(otherVal.path || '', otherVal.value || '', otherVal.name || '', otherVal.indexType || '');
        return v1 === v2;
      });

      _async2.default.eachLimit(uniq, 100, function (u, eaCb) {
        u.action = 'remove';
        _this12._indexField(u, options, eaCb);
      }, fn);
    }

    /*!
     * Creates an instance of this model from raw couchbase document
     * @param getRes
     * @returns {Function}
     */

  }, {
    key: '_populateAll',


    /*!
     * Populate everything
     * @param refs
     * @param options
     * @param memo
     * @param missing
     * @param fn
     */
    value: function _populateAll(refs, options, memo, missing, fn) {
      var _this13 = this;

      _async2.default.eachLimit(refs, 20, function (path, eachCB) {
        var id = _mpath2.default.get(path, _this13);
        var RefModel = _this13._getRefModel(path);
        if (!RefModel || !id) {
          return eachCB();
        }

        if (id instanceof RefModel) {
          return eachCB();
        }

        RefModel._findById(id, options, memo, function (err, results, missed) {
          if (err) {
            _this13._broadcast('error', err, _this13);
            return eachCB(err);
          }

          if (results) {
            _mpath2.default.set(path, results, _this13);
          }

          if (missed && missed.length > 0) {
            utils.concatArrays(missing, missed);
          }
          return eachCB();
        });
      }, function (err) {
        return fn(err, _this13, missing);
      });
    }

    /*!
     *
     * @param options
     * @param memo
     * @param missing
     * @param fn
     * @returns {*}
     */

  }, {
    key: '_populatePath',
    value: function _populatePath(options, memo, missing, fn) {
      var _this14 = this;

      var parts = options.populate.path.split('.');
      var part = parts[0];

      // Flag for non-model nested property. We need to use the full path for population.
      var fullPath = false;
      var path = void 0;
      if (this.schema.hasRefPath(part)) {
        path = part;
      } else if (this.schema.hasRefPath(options.populate.path)) {
        path = options.populate.path;
        fullPath = true;
      }

      // first part must be a ref path and cannot be a digit
      if (!path || DIGIT_REGEX.test(path)) {
        return process.nextTick(function () {
          return fn(null, _this14, []);
        });
      }

      var opts = (0, _clone2.default)(options);
      var Model = void 0;
      if (!fullPath) {
        var nextPart = parts[1];
        var restIndex = 1;
        // if next part is an array index append it to path and adjust
        if (nextPart && DIGIT_REGEX.test(nextPart)) {
          path = part.concat('.', nextPart);
          restIndex = 2;
        }

        // create the rest of path
        var rest = void 0;
        if (parts.length > restIndex) {
          rest = parts.slice(restIndex).join('.');
        }

        // get model
        Model = this._getRefModel(part);
        if (!Model) {
          console.warn('No model for path: %s', part);
          return process.nextTick(function () {
            return fn(null, _this14, []);
          });
        }

        // adjust the populate option for the rest
        opts.populate.path = rest;

        var targetParts = void 0;
        if (_lodash2.default.isString(options.populate.target) && options.populate.target) {
          targetParts = options.populate.target.split('.');
          opts.populate.target = targetParts.slice(restIndex).join('.');
        }
      } else {
        Model = this._getRefModel(path);
      }

      // get the ref key
      var id = _mpath2.default.get(path, this);
      if (!id || id instanceof Model) {
        return process.nextTick(function () {
          return fn(null, _this14, []);
        });
      }

      // get the ref doc and populate the rest recursively
      Model._findById(id, opts, memo, function (err, results, missed) {
        if (err) {
          _this14._broadcast('error', err, _this14);
          return fn(err);
        }
        if (results) {
          var dest = path;
          if (_lodash2.default.isString(options.populate.target) && options.populate.target) {
            if (fullPath) {
              dest = options.populate.target;
            } else {
              // set up dest based on target similarly to how we did path
              var _targetParts = options.populate.target.split('.');
              var targetPath = _targetParts[0];
              var nextTargetPart = _targetParts[1];
              // if next part is an array index append it to path and adjust
              if (nextTargetPart && DIGIT_REGEX.test(nextTargetPart)) {
                targetPath = targetPath.concat('.', nextTargetPart);
              }

              dest = targetPath;

              // if populating array element, or within array, lets fill in stuff that's not there first
              var basePath = parts[0];

              var targetProp = _mpath2.default.get(_targetParts[0], _this14);
              var temp = (0, _clone2.default)(_mpath2.default.get(basePath, _this14));
              if (targetProp) {
                targetProp = _lodash2.default.defaultsDeep(targetProp, temp);
              } else {
                targetProp = temp;
              }
            }
          }

          _mpath2.default.set(dest, results, _this14);
        }

        if (missed && missed.length > 0) {
          utils.concatArrays(missing, missed);
        }

        return fn(err, _this14, missing);
      });
    }

    /*!
     * Populates embedded documents into this instance based on populate options
     * @param options
     * @param fn
     * @returns {*}
     */

  }, {
    key: '_populate',
    value: function _populate(options, memo, fn) {
      var _this15 = this;

      if (typeof options === 'function') {
        fn = options;
        memo = null;
        options = {};
      }

      if (typeof memo === 'function' && !fn) {
        fn = memo;
        memo = null;
      }

      if (!fn) {
        fn = _lodash2.default.noop;
      }

      if (!options) {
        options = {};
      }

      if (!cdocUtils.hasPopulate(options)) {
        return process.nextTick(function () {
          return fn(null, _this15, []);
        });
      }

      var refs = this._getSortedRefPaths(true);
      if (!refs || refs.length === 0) {
        return process.nextTick(function () {
          return fn(null, _this15, []);
        });
      }

      var missing = [];

      if (options.populate === true) {
        // recursively populate everything
        this._populateAll(refs, options, memo, missing, fn);
      } else if (_lodash2.default.isString(options.populate)) {
        options.populate = { path: options.populate };
        this._populatePath(options, memo, missing, fn);
      } else if (_lodash2.default.isPlainObject(options.populate)) {
        this._populatePath(options, memo, missing, fn);
      } else if (Array.isArray(options.populate)) {
        _async2.default.eachLimit(options.populate, 20, function (part, eaCb) {
          var opts = (0, _clone2.default)(options);
          opts.populate = part;
          return _this15._populate(opts, memo, eaCb);
        }, function (err) {
          return fn(err, _this15, missing);
        });
      }
    }

    /*!
     * emits the event using all of our emitters
     */

  }, {
    key: '_broadcast',
    value: function _broadcast() {
      var _constructor, _privateKey$lounge;

      if (arguments[0] === 'error') {
        var err = arguments[1];
        if (err instanceof Error) {
          debug(err.message);
        }
      }
      this.emit.apply(this, arguments);
      (_constructor = this.constructor).emit.apply(_constructor, arguments);
      (_privateKey$lounge = this[_privatekey2.default].lounge).emit.apply(_privateKey$lounge, arguments);
    }

    /*!
     * calls the callback fn with results based on missing opetions
     */

  }, {
    key: 'cas',
    get: function get() {
      return this.getCAS();
    }

    /**
     * Gets the database driver of the model
     * @returns {Driver|null}
     */

  }, {
    key: 'db',
    get: function get() {
      return this[_privatekey2.default].db;
    }

    /**
     * Gets the config object
     * @returns {Object}
     */

  }, {
    key: 'config',
    get: function get() {
      return this[_privatekey2.default].config;
    }
  }], [{
    key: '_createModelObject',
    value: function _createModelObject(getRes) {
      if (getRes && getRes.value) {
        var objData = getRes.value;
        var cas = getRes.cas;
        return new this.prototype.constructor(objData, {}, cas);
      }
    }
  }, {
    key: '_callback',
    value: function _callback(fn, options, err, result, missing) {
      if (this.config.missing === false) {
        if (options.missing === true) {
          return fn(err, result, missing);
        }

        return fn(err, result);
      }

      if (options.missing === false) {
        return fn(err, result);
      }

      return fn(err, result, missing);
    }

    /*!
     * utility to wrap the callback fn and use our _callback
     */

  }, {
    key: '_wrapCallback',
    value: function _wrapCallback(fn, options) {
      var _this16 = this;

      return function (err, result, missing) {
        return _this16._callback(fn, options, err, result, missing);
      };
    }

    /**
     * All models created come with a static function <code>findById</code> that can be used to look up a single
     * or multiple keys and retrieve documents from the database. If key does not exist and document is not found we
     * **do not** return an error but also no model is generated. This is different than present couchbase module behaviour.
     * @param {String|Array} id the document id / key or an array of keys
     * @param {Object} options
     * @param {Boolean|String|Array} options.populate - populate options, can be a <code>Boolean</code>;
     *                               <code>String</code> representing a path;
     *                               <code>Object</code> with form <code>{ path: String, target: String}</code> where
     *                               <code>path</code> is the path to be populated and <code>target</code> is the target
     *                               field into which to populate. If this format is used, <code>target</code> should be
     *                               part of schema;
     *                               or an <code>Array</code> of
     *                               <code>Strings</code> or <code>Object</code>.
     * @param {Boolean} options.keepSortOrder If getting an array of objects, whether we should keep same sort order of
     *                                        returned objects as the <code>id</code>'s passed in.
     *                                        Default: <code>false</code>
     * @param {Boolean} options.missing If set to <code>false</code> we won't return missing keys as the final param in
     *                                  the callback. This option overwrites the Lounge config <code>missing</code> option.
     *                                  Default: <code>true</code>.
     * @param {Function} fn callback
     * @example User.findById('user123', function(err, doc, missing) {
     *   if(err) console.log(err); // there was an error looking up the key
     *   else if(!doc) console.log('no document found');
     *   else console.log(doc); // doc is instance of User and will print it out
     * });
     */

  }, {
    key: 'findById',
    value: function findById(id, options, fn) {
      return utils.promisifyCall.apply(utils, [this, this._findByIdImpl].concat(Array.prototype.slice.call(arguments)));
    }
  }, {
    key: '_findByIdImpl',
    value: function _findByIdImpl(id, options, fn) {
      if (typeof options === 'function') {
        fn = options;
        options = {};
      }

      if (!options) {
        options = {};
      }

      if (!fn) {
        fn = _lodash2.default.noop;
      }

      if (this.config.alwaysReturnArrays && !Array.isArray(id)) {
        id = [id];
      }

      if (Array.isArray(id)) {
        id = _lodash2.default.compact(id);
      }

      if (!id || _lodash2.default.isEmpty(id)) {
        return process.nextTick(function () {
          return fn(null, null, []);
        });
      }

      var memo = new _memodriver2.default(this.db);
      var modelName = this.modelName;
      debug(modelName + '.findById. id: ' + id);

      this._findById(id, options, memo, this._wrapCallback(fn, options));
      memo.clear();
    }
  }, {
    key: '_findById',
    value: function _findById(id, options, memo, fn) {
      var _this17 = this;

      if (typeof memo === 'function' && !fn) {
        fn = memo;
        memo = null;
      }

      var driver = memo ? memo : this.db;

      // helper sort function used later
      function sortModels(models) {
        if (options.keepSortOrder) {
          models = _lodash2.default.sortBy(models, function (o) {
            return id.indexOf(o.getDocumentKeyValue());
          });
        }

        return models;
      }

      if (Array.isArray(id)) {
        var fullIds = _lodash2.default.map(id, function (curId) {
          return _this17.getDocumentKeyValue(curId, true);
        });

        driver.get(fullIds, function (err, results, misses) {
          if (err) {
            return fn(err, results, misses);
          }

          if (!results || results.length === 0) {
            return fn(err, [], misses);
          }

          var modelObjs = _lodash2.default.map(results, _lodash2.default.bind(_this17._createModelObject, _this17));

          if (!cdocUtils.hasPopulate(options)) {
            modelObjs = sortModels(modelObjs);
            return fn(err, modelObjs, misses);
          }

          _async2.default.eachLimit(modelObjs, 100, function (modelObj, eachCB) {
            modelObj._populate(options, memo, function (err, popObj, missed) {
              if (missed && missed.length > 0) {
                utils.concatArrays(misses, missed);
              }
              return eachCB(err);
            });
          }, function (err) {
            modelObjs = sortModels(modelObjs);
            return fn(err, modelObjs, misses);
          });
        });
      } else {
        id = this.getDocumentKeyValue(id, true);
        driver.get(id, function (err, getRes) {
          if (err) {
            return fn(err);
          }

          var modelObj = _this17._createModelObject(getRes);
          if (!modelObj) {
            return fn();
          }

          modelObj._populate(options, memo, fn);
        });
      }
    }

    /**
     * Removes specified document(s).
     * @param {String|Array} id - id(s) to remove
     * @param {Object} options - options
     * @param {Boolean} options.lean - if <code>true</code> we will directly do document removal. We do not create an instance of model.
     *                                 No middleware is invoked. No indexes updated. Embedded documents are not deleted. Default: <code>false</code>.
     * @param {Boolean} options.removeRefs - If set to <code>true</code> will remove embedded reference documents. Default: <code>false</code>.
     * @param {Function} fn - callback
     * @example
     * User.remove('user123', function(err, doc) {
     *   if(err) console.log(err);
     * });
     */

  }, {
    key: 'remove',
    value: function remove(id, options, fn) {
      return utils.promisifyCall.apply(utils, [this, this._remove].concat(Array.prototype.slice.call(arguments)));
    }
  }, {
    key: '_remove',
    value: function _remove(id, options, fn) {
      var _this18 = this;

      if (typeof options === 'function') {
        fn = options;
        options = {};
      }

      if (!options) {
        options = {};
      }

      if (!fn) {
        fn = _lodash2.default.noop;
      }

      if (!Array.isArray(id)) {
        id = [id];
      }

      id = _lodash2.default.compact(id);

      if (!id || _lodash2.default.isEmpty(id)) {
        return process.nextTick(function () {
          return fn(null);
        });
      }

      if (options.lean) {
        return _async2.default.eachLimit(id, 100, function (did, eaCb) {
          var fullid = _this18.getDocumentKeyValue(did, true);
          _this18.db.remove(fullid, eaCb);
        }, function (err) {
          return fn(err);
        });
      }

      this.findById(id, function (err, docs) {
        if (err) {
          return fn(err);
        }

        if (docs && docs.length === 1) {
          return docs[0].remove(options, fn);
        }

        _async2.default.eachLimit(docs, 100, function (doc, eaCb) {
          doc.remove(options, eaCb);
        }, fn);
      });
    }

    /*!
     * Find by index document value. generic implementation that we hook up into Models.
     * @param param
     * @param indexPath
     * @param options
     * @param fn
     */

  }, {
    key: '_findByIndexValue',
    value: function _findByIndexValue(param, indexPath, options, fn) {
      var _this19 = this;

      if (typeof options === 'function') {
        fn = options;
        options = {};
      }

      if (!options) {
        options = {};
      }

      if (!fn) {
        fn = _lodash2.default.noop;
      }

      var modelName = this.modelName;
      debug(modelName + '.findByIndexValue. value: ' + param + ' path: ' + indexPath);

      this.db.get(param, function (err, res) {
        if (err || !res || !res.value || !res.value.key && !res.value.keys) {
          var indexDef = _lodash2.default.get(_this19.schema.indexes, schemaUtils.getIndexName(indexPath));
          if (_this19.config.alwaysReturnArrays || indexDef && indexDef.indexType === 'array') {
            return fn(err, []);
          }
          return fn(err);
        }

        var idToGet = res.value.key || res.value.keys;

        if (options.lean) {
          if (_this19.config.alwaysReturnArrays && !Array.isArray(idToGet)) {
            idToGet = [idToGet];
          }
          return fn(err, idToGet);
        }

        return _this19.findById(idToGet, options, _this19._wrapCallback(fn, options));
      });
    }
  }]);

  return CouchbaseDocument;
}(_document2.default);

exports.default = CouchbaseDocument;